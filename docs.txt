yarn global add live-server
=> we will need to see the html js output again and again 
> we will use expres ffor our production, livescript while we are developing and webpack for localhost 

Use live-server public for seeing the output of everything in public folder
right now we are using script tag to insert react react dom redux but later we will use webpack for it which is easy
react allows  us to create js code which creates components => components are the html codes 
=> to render/insert this html to DOM, we use react-dom library

create app.js which will create all the react or js code => and include this file in the html

JSX is JS XML which is extension for JS just like we have SAAS as extension for CSS

If we create a JSX code and try to render it inside html code like by inserting in div => it will show error 
=> this is because, the JSX code is not understood by the browser => we use babel for that

babel is a Javascript compiler. It helps us in many conversions -
1) JSX to plain old js => like needed here
2) ES6/ES7 to ES5 => ES6/6 comes with variety of new features like arrow function but these wont work on every browser because there are still some browser who dont support it yet and maybe never will 
=> for browser compatibility, we must convert ES6/7 anywhere in our code to plain old js => i,e, we maybe wrting Es6 but it will convert to Es5 in the end => and we know it can run everywhere

On babel website you can see conversion 
React.createElemet (tag name, attribute array, content ) 

=> but we want to automate this conversion and thus we will use babel library for that locally 
=> replace jsx by its equivalent code for old js given by babel 
and it works fine 

now we will install the babel and some of its presets => we will install react preset, the env preset which helps in getting us all es6 and es7 features
yarn global add babel-cli => comamnd line to access babel
babel --help 

Like in node, we used npm init for config of the project, here it is the yarn which does all that work like adding dependencies or init 
=> yarn init before every project

Now we will add the presets as dependency in package.json using the yarn module yarn add babel-preset-react

Now lets create app.js in src folder => this is js file where we will write our JSX code => then using babel commanline we will convert this code into old javascript code by outputing it into scripts/app.js
In commandline => babel src/app.js --out-file=public/scripts/app.js --presets=env,react

If we use this with --watch => it will keep running in background and make changes as we make any changes

We dont upload node modules on git or anything => to reinstall them on your machine, do yarm install just like we did npm install in node

Babel errors will appear in the terminal => when we give 2 root elements in JSX =>it throws error because JSX can have only one rrot element 

Now we willl see how to create dynamic templates => uise {variable name} tp insert any js content into template
 => dont't put object variable bcoz it wont know what to do with object 

 Now we will see conditional jSX => if log in then render this else render that => this type of stuff 
 => 1) we do it by making functions => we call function and it will contain conditions based on which it will return the var => we call this function inside {}
 2) Note that we can also do templating inside {} => actually, the function can return template as well based on condition like we have done 
 3) See that inside the function we are checking that if location exist then send template with dynamic location var inserted back to the caller which will again dynamically be rendered 
Now if the location is undefined => no need to do else retunr... => this is becuase if not exist, function will auto return undefined 
=> u will obeserve that in undefined case => it will become {undefined} at the caller side => in such a case i.e. {undefined} => nothing is rendered 
=> VIMP => by doing this we were able to di this : if location exist, create <p> template containing location else if not, then do nothing..no <p> is created, no location added as if we never did anything there 
Test this by removing location or makingit undefined 

Now let learn ternary operator which comes very handy many times
=> Before this, note that {undefined} is not rendered in JSX => {true} or {false} or {null} will not be rendered too as they are undefined  => this is imp feature which makes things easier and neat
Now ternary => {user.name ? user.name : 'ccecr'} => if user.name will exist, it is true else undefined will correspond to false 

Next we will learn logical AND operator => these are little different than java => true && 'soem text' gives 'some text' => false && 'some text' gives false
=> {user.age>=18 && (here put whatever you want to render if true)} => if not true, it will be false/undefined => nothign rendered like in earlier cases 

=> 3 techniques => ternary, AND operator or simple if else by calling a function

Now look at the playground/es6 for types of varibaled in es6 javascript
Now lets look at the arrow function => in normal function, var f = function(a,b) you may call f(1,2,3) => you may pass no. of arguments not same as in signature BUT still inside function you can do log(arguments) to access all arguments BUT in arrow function,
1) You can't access arguments and you must stricylt follow the signature while calling function otherwie it will throw error
2) Arrow function uses "this" of their parent scope 
=> 
const user = {
    name : 'Andrew',
    cities: ['Delhi','Pune'],
    printFunc : function(){
        this.cities.forEach((city)=>{
            console.log(this.name);
        });
    }
}
=> above inside forEach we have used arrow function => inside this function if you use "this" => what will be the scope that "this" will refer to ?? => It wont refer to scope inside of arrow function 
=> in arrow function "this" referes to scope of parent "this" => parent of this arrow function is scope = inside of object 
=> this inside arrow = this inside object scope => this referes to object 
 
=> Had it been normal function => "this would have refreed to scope = scope inside function " => this.cities would have shown error because, there are no cities inside function scope (="this" scope)

In JSX , inside <button>, its not class. It is className
Search react DOM on google for more such attributes in JSX corresponding to their HTML equivalent => all of them are camelcase

You can also give value of id or class in JSX through a variable too like button id={var} or button onClick = {function_name}

Now are making counter app using event handlers => we have created a template with button and text => added a count as a variable in it => inside onClick on +/-, we are first changing same count variable we put in template
=> but we also need to render the new value => Now we have put template and render function inside some function => this will be called whenever we have to render things => it will be called first time for init and then just after count var value is changed

But if you see everytime we call this rendering func, it will recreate the same template and re render which will be overkill for big apps => but react handles it efficiently 
=>  Some developer tools note : Open dev tools elements tab => click on button now and see the elements tab => it will flash everything that is re rendered by react 
also you will see some comments realted to react which also helps 

Now we will see how to create forms => simply add form in template => Now, since on submitting a form in browser, the page sends thr data in url we want to avoid this default behavior => add onSubmit inside your form and give the function where we will handle this case
Now onSubmit={onFormSubmit} => dont make it {onFormSubmit()} because then you will be calling the function and it will return undefined => we dont want that 
=> Now inside onFormSubmit function we will be receiing the event e argument by default => call prevent default
We can get the form elements as e.target.elements => Now access element by its name => name = option for textfield => .option.value will give value by user in this element 
=> Now push this element to the options array in app object and then clear the field so user can submit new entry in the form 
Now though we have got array of all options in array But it is in js, not jsx => how to use it in jsx => 
JSX supports js arrays, strings, numbers AND ignores objects, booleans, undefined, null  by using {put code here like we did variables}
=> For array => again put array inside {} => Though null undefined etc can be used but they will be ignored in array
=> { [1,2,3] } => actually it will be breaked down to individual jsx elements => {1},{2,{3}} i.e. as if we have defined multiple {number} jsx
Array can contain the tags as well 
[<p>A</p>,<p>B</p>]  
=> though it will be rendered, we will have error in the consolde => actually JSX uses keys for optimisation processs => to keep track of these array jsx elements, a key has to be attached at the time of declaring them which will 
be used by JSX for internal references and provide optimisation in renderign For ex => to know that this element is same as before and don;t need to be rendered again 
=> If you give key=1 to <p> and then dynamically changes key to 2 => JSX will treat this element as new one and will create new instead of re rendering => however if key is same, it knows that it is same and it will only modify the changes

Now we can execute some code inside { code here} which will return us any JSX expression 
=>  we can use maps to iterate over options array and for each of them return li tag 

Components => we can break our app inti small componenets => has its own JSX, events => reusable self contained units 
on any page we can break the page into components => there will be one parent tag and all other componenets can be used by their name as if they are html tags => their implementation will be abstracted 

ES6 classes => though we already studied about it in Node lectures => One of the ES6 feature is to have optional arguments -
1) constructor(name = 'Anonymous'){   // => if name not passed, it is anonymous by default 
    ....
}
2) constructor (name){
this.name = name || 'test';   //=> if name not given, take value as test else as name 
}

If inheriting parent class => call its constructor before setting your values b super 


Creating components

1) Create a component => crete a class with camelcase name and it must extend the React.Component class 
2) Override the render method in which define the jsx for your react component 
3) Now you can use all the components you created above in your jsx code by treating component class as tags and render it by using ReactDom.render (jsx,where to insert)

We can create our complete app as a  React component class => make Indecision app itself as component and then inside it use other components 
=> it is like components inside components => another example is use of option component inside options class/component => it is nexting of components 
=> whenever you need component inside component => use it inside code of parent render() function 

Props of components 
=> let say you have a component but you want to reuse it but with different data => props helps us 
=> while using any component <Header/> we can send data with it in form of attribute => this attribute/data/prop will be accessible to us inside this component's class 
=> this.props contain all the props that are sent to us and you can thus set that data to component 

=> in code, we first created array of options and then sent it as prop to options compo and then inside it using map, for each of them, we created option component by sending data for each of them as popr to Option compnent 
=> the key is added since we are using jsx arrays

the props allowed us to communicate in one direction only => to coomunicate in other, we use handlers/event handlers 
=> within component, if inside render, you have button and its onClick => define its onclick handler within the same class 
=> we have done this for a form inside addOption class component 

Now lets see binding 
=> when you call this.handleRemoveAll inside render() of component, it works or if you use this.props 
but if inside the handleRemoveAll method of component class itself, if you use this.props () => will show error => why ?
when you said onClick = handleRemoveAll, you didn't do function call like any java etc handleRemoveAll() => you just passed reference to the object 
=> react just got referene to the function object..it doesn't know which scope this function was in => it dont know what "this" meant inside func => bcoz it just got the function 
=> "this" inside handleRemoveAll refers to the window and not the current component object 
=> since render() function is always associted with component class, react knew that "this" means the current object
=> while passing function reference to react for onClick, we must also pass the scope "this" of this function => we must pass that which scope will be used for this function 
=> you should do, onClick = this.handleRemoveAll.bind(scope you want which is nothing but current "this") 
OR 
=> you can also, use constructor to do so => the constructor always receieve a parameter props => inside constructor, first super the props as we dont want to mess with its internal functioning
=> then you can call this.handleRemoveAll (means the class function) = this.handleRemoveAll.bind(this) (mean the class function along with scope specified to it)
=> remember that like render(), inside constructor also, the "this" referes to object only 

You should prefer 2nd one bcoz render is called again and again and doing same thing unneceesary is not good 
